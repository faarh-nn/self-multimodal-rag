import os
import pandas as pd
from typing import List
from evaluation_module import EvaluationModule
from dotenv import load_dotenv
load_dotenv()


OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

METRICS = ['Answer Correctness', 'Answer Relevancy']
IMAGE_METRICS = ['Image Faithfulness', 'Image Context Relevancy']
TEXT_METRICS = ['Text Faithfulness', 'Text Context Relevancy']
AGGREGATED_METRICS = ['Faithfulness', 'Context Relevancy']



def evaluate_row(metrics: List[str], index: int, context: str, image: List[str], user_query: str, generated_answer: str,
                 reference_answer: str, evaluator: str, scores_df: pd.DataFrame) -> pd.DataFrame:
    """
    Evaluates the results for one output of a RAG system.

    :param metrics: A list of metrics to be evaluated.
    :param index: Index of the current row in the dataframe.
    :param context: Textual context retrieved by the retrieval system.
    :param image: Base64 encoded string of an image retrieved by the retrieval system.
    :param user_query: Question to be answered by the RAG system.
    :param generated_answer: Answer generated by the RAG system.
    :param reference_answer: Gold standard answer to the user query.
    :param evaluator: Model to be used as evaluator (should be gpt4_vision or llava).
    :param scores_df: A dataframe containing the evaluation results.
    
    :return: A dataframe containing the evaluation results.
    """
    results = evaluator.evaluate(metrics=metrics,
                                query=user_query,
                                context=context,
                                image=image,
                                generated_answer=generated_answer,
                                reference_answer=reference_answer)
    print(results)
    for k, v in results.items():
        scores_df.at[index, f"{k} grade"] = v["grade"]
        scores_df.at[index, f"{k} reason"] = v["reason"]

    return scores_df


def handle_no_data(index, data_type: str, scores_df: pd.DataFrame) -> pd.DataFrame:
    """
    Defines behaviour for cases where no text or image is provided as context.
    In this case the grade will be None and the reason is, that no data has been provided.

    :param metrics: A string indicating the missing data type (text or image).
    :param scores_df: A dataframe containing the evaluation results.
    
    :return: A dataframe containing the evaluation results.
    """  
    scores_df.at[index, f"{data_type} Faithfulness grade"] = None
    scores_df.at[index, f"{data_type} Faithfulness reason"] = f"No {data_type} provided"
    scores_df.at[index, f"{data_type} Context Relevancy grade"] = None
    scores_df.at[index, f"{data_type} Context Relevancy reason"] = f"No {data_type} provided"
    return scores_df


def evaluate_dataframe(input_df: pd.DataFrame, evaluator: str, output_file: str) -> pd.DataFrame:
    """
    Evaluates the outputs of a RAG system.

    :param input_df: Dataframe containing the outputs of a RAG system.
    :param evaluator: Model to be used as evaluator (should be gpt4_vision, or llava).
    :param output_file: json file where the evaluation results are stored.
    
    :return: A dataframe containing the evaluation results.
    """
    scores_df = pd.DataFrame()
    for index, row in input_df.iterrows():
        print(f"Evaluating query no. {index+1}...")
        user_query = input_df["user_query"][index]
        reference_answer = input_df["reference_answer"][index]
        generated_answer = input_df["generated_answer"][index]
        context = input_df["context"][index]
        image = input_df["image"][index] if input_df["image"][index] else []
        metrics = METRICS.copy()
        if not image:
            scores_df = handle_no_data(index, "Image", scores_df)
        else:
            metrics.extend(IMAGE_METRICS)
        if not context:
            scores_df = handle_no_data(index, "Text", scores_df)
        else:
            metrics.extend(TEXT_METRICS)
        scores_df = evaluate_row(metrics, index, context, image, user_query, generated_answer, reference_answer, evaluator, scores_df)
                
        for metric in AGGREGATED_METRICS:
            # calculating overall faithfulness and context relevancy for image and text combined
            img_metric = scores_df.at[index, f"Image {metric} grade"]
            text_metric = scores_df.at[index, f"Text {metric} grade"]
            
            df_tmp = pd.DataFrame()
            df_tmp[metric] = [img_metric, text_metric]
            
            grade = df_tmp[metric].mean()
            scores_df.at[index, f"{metric} grade"] = grade
        
        scores_df.to_json(output_file, orient="records", indent=2)
    return scores_df
  
  
def calculate_and_print_averages(scores_df: pd.DataFrame):
    """
    Averages the scores for each metric over the entire dataset and prints them.
    :param scores_df: Dataframe containing the evaluation results.
    """
    average_dict = {}
    for grade in METRICS + IMAGE_METRICS + TEXT_METRICS + AGGREGATED_METRICS:
        average_dict[grade] = scores_df[f'{grade} grade'].mean()
        print(f"{grade.capitalize()}: {average_dict[grade]}")
        


if __name__ == "__main__":
    generator_model = "gpt-4o-mini"   # model that was used as generator in the rag pipeline to be evaluated
    evaluator_model = "gpt-4o-mini"   # choose among llava and gpt4_vision

    # json file containing the results of a rag pipeline
    rag_output_file = rf"data/rag_outputs/rag_output_{generator_model}_baseline.json" # perlu diubah ke file yang sesuai
    # file for saving evaluaton results
    evaluation_output_file = rf"data/rag_evaluation_results/evaluation_{evaluator_model}_evaluator_baseline.json"

    evaluator = EvaluationModule(evaluator_model)

    input_df = pd.read_json(rag_output_file)
    scores_df = evaluate_dataframe(input_df, evaluator, evaluation_output_file)
    calculate_and_print_averages(scores_df)